// Copyright (C) 2020,2024 azumakuniyuki and sisimai development team, All rights reserved.
// This software is distributed under The BSD 2-Clause License.
package sis

//  _____          _   
// |  ___|_ _  ___| |_ 
// | |_ / _` |/ __| __|
// |  _| (_| | (__| |_ 
// |_|  \__,_|\___|\__|
//                     
import "os"
import "fmt"
import "time"
import "encoding/json"
import a "sisimai/address"

// sisimai/fact.Rise() returns []sis.Fact
type Fact struct {
	Action          string         `json:"action"`         // The value of "Action:" field
	Addresser       a.EmailAddress `json:"addresser"`      // The sender address of the original message
	Alias           string         `json:"alias"`          // The alias of the recipient address
	Catch           interface{}    `json:"catch"`          // Results generated by the user-defined callback function[1]
	DeliveryStatus  string         `json:"deliverystatus"` // "Status:" field value or the delivery status such as "5.2.2"
	Destination     string         `json:"destination"`    // The domain part of the "Recipient"
	DiagnosticCode  string         `json:"diagnosticcode"` // "Diagnostic-Code:" field value or error messages in the message body
	DiagnosticType  string         `json:"diagnostictype"` // The subtype of "Diagnostic-Code:" field such as "SMTP", "X-UNIX"
	FeedbackID      string         `json:"feedbackid"`     // The value of Feedback-ID: header of the original message
	FeedbackType    string         `json:"feedbacktype"`   // Feedback Type, always empty except when the Reason is "feedback"
	HardBounce      bool           `json:"hardbounce"`     // Hard bounce or not: true, false
	Lhost           string         `json:"lhost"`          // The hostname of the local mail server (the server attempting to send the email).
	ListID          string         `json:"listid"`         // The value of "List-Id" field of the original message
	MessageID       string         `json:"messageid"`      // The value of "Message-Id:" header of the original message
	Origin          string         `json:"origin"`         // The path of the bounce mail as a data source
	Reason          string         `json:"reason"`         // The Bounce reason name, which sisimai detected
	Rhost           string         `json:"rhost"`          // The hostname of the remote mail server (the server intended to receive the email).
	Recipient       a.EmailAddress `json:"recipient"`      // The recipient address of the original message
	ReplyCode       string         `json:"replycode"`      // SMTP Reply Code such as "421", which is picked from the error message
	DecodedBy       string         `json:"decodedby"`      // MTA module name
	Command         string         `json:"command"`        // The last SMTP command
	SenderDomain    string         `json:"senderdomain"`   // The domain part of the "Addresser"
	Subject         string         `json:"subject"`        // The value of Subject: header of the original message
	Timestamp       time.Time      `json:"timestamp"`      // Unix machine time(int64) of that the email bounced
	TimezoneOffset  string         `json:"timezoneoffset"` // Time zone offset of "Timestamp", such as "+0900"
	Token           string         `json:"token"`          // The Message token(MD5 Hex digest value)
}

// MarshalJSON() returns serialized JSON string of "Addresser", "Recipient", and "Timestamp"
func(this Fact) MarshalJSON() ([]byte, error) {
	// @param    NONE
	// @return   string  A part of sis.Fact{} fields as a JSON string
	type AnotherOne Fact // To avoid an infinite loop
	return json.Marshal(&struct {
		Addresser string `json:"addresser"`
		Recipient string `json:"recipient"`
		Timestamp int64  `json:"timestamp"`
		AnotherOne
	}{
		Addresser:  (this).Addresser.Address,
		Recipient:  (this).Recipient.Address,
		Timestamp:  (this).Timestamp.Unix(),
		AnotherOne: (AnotherOne)(this),
	})
}

// Dump() returns a serialized sis.Fact{} structure as a JSON string
func(this Fact) Dump() string {
	// @param    NONE
	// @return   string  Serialized sis.Fact{} as a JSON string
	if jsonb, nyaan := json.Marshal(this); nyaan != nil {
		// Failed to serialize, returns an empty string
		fmt.Fprintf(os.Stderr, " *****error: %s\n", nyaan)
		return ""

	} else {
		// Successfully serialized
		return string(jsonb)
	}
}

